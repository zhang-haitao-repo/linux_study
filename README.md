# 1 编译流程及库的制作

## 1.1 编译流程

### 1.1.1 gcc的工作流程:

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml4980\wps46.png)

1 预处理: cpp预处理器, 去掉注释, 展开头文件, 宏替换
	gcc -E test.c -o test.i
2 编译: gcc, 将源代码文件编译成汇编语言代码
	gcc -S test.i -o test.s
3 汇编: as, 将汇编语言代码编译成了二进制文件(目标代码)
	gcc -c test.s -o test.o
4 链接: ld, 链接test.c代码中调用的库函数
	gcc -o test test.o

一步生成最终的可执行程序: 
gcc test.c -o test

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml4980\wps17.png)

### 1.1.2 gcc常用参数

-v  查看gcc版本号, --version也可以

-E  生成预处理文件

-S  生成汇编文件

v-c  只编译, 生成.o文件, 通常称为目标文件

-I   指定头文件所在的路径

-L   指定库文件所在的路径

-l    指定库的名字

-o   指定生成的目标文件的名字

-g   包含调试信息, 使用gdb调试需要添加-g参数

-On n=0∼3 编译优化,n越大优化得越多

-Wall 提示更多警告信息

-D  编译时定义宏


## 1.2 静/动态库

### 1.2.1 静态库

库是二进制文件, 是源代码文件的另一种表现形式, 是加了密的源代码; 

- 提高代码的可重用性, 而且还可以提高程序的健壮性;
- 可以减少开发者的代码开发量, 缩短开发周期.
- 头文件---包含了库函数的声明
- 库文件---包含了库函数的代码实现

步骤2：使用打包工具ar将准备好的.o文件打包为.a文件，在使用ar工具是时候需要添加参数rcs

- r更新、c创建、s建立索引
- 命令：ar rcs 静态库名 .o文件

![image-20210121112043562](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210121112043562.png)

**静态库的制作:**

- 1 将.c文件编译成.o文件
  		gcc -c fun1.c fun2.c
- 2 使用ar命令将.o文件打包成.a文件
  		ar rcs libtest1.a fun1.o fun2.o

**静态库的使用:**

- 1 main.c与head.h和libtest1.a在同一级目录的情况
  		gcc -o main1 main.c -I./ -L./ -ltest1	
- 2 main.c与head.h和libtest1.a在不同一级目录的情况
  		gcc -o main1 main.c -I./include -L./lib -ltest1

**静态库的优缺点**

- 优点：
  - 函数库最终被打包到应用程序中，实现是函数本地化，寻址方便、速度快。
  - （库函数调用效率==自定义函数使用效率）
  - 程序在运行时与函数库再无瓜葛，移植方便。
- 缺点：
  - 消耗系统资源较大, 每个进程使用静态库都要复制一份, 无端浪费内存。

![image-20210121141151499](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210121141151499.png)

### 1.2.2 动态库

- 共享库在程序编译时并不会被连接到目标代码中, 而是在程序运行是才被载入. 

- 不同的应用程序如果调用相同的库, 那么在内存里只需要有一份该共享库的拷贝, 规避了空间浪费问题.

- 动态库在程序运行时才被载入, 也解决了静态库对程序的更新、部署和发布会带来麻烦。

- 用户只需要更新动态库即可, 增量更新. 为什么需要动态库, 其实也是静态库的特点导致. 

  

  ![image-20210121153622972](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210121153622972.png)

**动态库的制作**

- 生成目标文件.o, 此时要加编译选项：-fPIC（fpic）
  - gcc -fpic -c fun1.c fun2.c
  - 参数：-**fpic**创建与地址无关的编译程序, 目的就是为了能够在多个应用程序间共享.
- 生成共享库, 此时要加链接器选项: -shared（指定生成动态链接库）
  - gcc -shared fun1.o fun2.o -o libtest2.so

**动态库的使用**

- -L：指定要连接的库的所在目录
- -l：指定链接时需要的动态库, 去掉前缀和后缀
- -I: 指定main.c文件用到的头文件head.h所在的路径
- gcc main.c -I./ -L./ -ltest2 -o main2

> 对于elf格式的可执行程序，是由ld-linux.so*来完成的, 它先后搜索elf文件的 DT_RPATH段 — 环境变量LD_LIBRARY_PATH — /etc/ld.so.cache文件列表 — /lib/, /usr/lib目录找到库文件后将其载入内存。

**如何让系统找到共享库**

- 临时设置LD_LIBRARY_PATH:
  - export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径 
- **永久设置, 把export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径, 设置到∼/.bashrc文件中, 然后在执行下列三种办法之一:**
  - **执行. ~/.bashrc使配置文件生效(第一个.后面有一个空格)**
  - **执行source ~/.bashrc配置文件生效**
  - **退出当前终端, 然后再次登陆也可以使配置文件生效**
- 永久设置,把export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径，设置到/etc/profile文件中(不建议)



### 1.2.3 优缺点

 **静态库的优点:**
 	1 执行速度快, 是因为静态库已经编译到可执行文件内部了
 	2 移植方便, 不依赖域其他的库文件
 **缺点:** 
 	1 耗费内存, 是由于每一个静态库的可执行程序都会加载一次
 	2 部署更新麻烦, 因为静态库修改以后所有的调用到这个静态库的可执行文
件都需要重新编译

 **动态库的优点:**
 	1 节省内存
 	2 部署升级更新方便, 只需替换动态库即可, 然后再重启服务.（**大型程序无需重新编译**）
 **缺点:** 
 	1 加载速度比静态库慢
 	2 移植性差, 需要把所有用到的动态库都移植.

由于由静态库生成的可执行文件是把静态库加载到了其内部, 所以静态库生成的可执行文件一般会比动态库大.



# 2 makefile和gdb

## 2.1 makefile

**makefile：**管理项目工程文件。

**makefile的编写:**
**规则:**

目标: 依赖
(tab)命令

第一个版本:

```makefile
main: main.c fun1.c fun2.c sum.c
	gcc -o main main.c fun1.c fun2.c sum.c
```

第二个版本:

```makefile
main: main.o func1.o func2.o sum.o
	gcc -o main main.o func1.o func2.o sum.o
main.o: main.c
	gcc -c main.c -I./
func1.o: func1.c
	gcc -c func1.c
func2.o: func2.c
	gcc -c func2.c
sum.o: sum.c
	gcc -c sum.c
```

   ![image-20210121165600699](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210121165600699.png)

第三个版本:
	变量: 
		自定义变量: var = hello, $(var)
		自带变量: CC CPPFLAGS CFLAGS LDFLAGS
		自动变量: $@目标  $<第一个条件  $^所有条件
	模式规则:
		%.o:%.c------> 前后的%必须是相同 

```makefile
target = main
object = main.o func1.o func2.o sum.o
CC = gcc
CPPFLAGS=-I./
$(target): $(object)
	$(CC) -o $@ $^
%.o:%.c
	$(CC) -c $< $(CPPFLAGS)
```



第四个版本:		
	1.wildcard – 查找指定目录下的指定类型的文件
	src=$(wildcard *.c)  //找到当前目录下所有后缀为.c的文件,赋值给src
	2.patsubst – 匹配替换
	obj=$(patsubst %.c,%.o, $(src)) //把src变量里所有后缀为.c的文件替换成.o

```makefile
src = $(wildcard ./*c)
object = $(patsubst %.c,%.o,$(src))
CC = gcc
CPPFLAGS=-I./
$(target): $(object)
	$(CC) -o $@ $^
%.o:%.c
	$(CC) -c $< $(CPPFLAGS)
```

第五个版本:
	增加清理功能.
	终极目标: makefile文件中第一次出现的目标叫做终极目标

```makefile
src = $(wildcard ./*c)
object = $(patsubst %.c,%.o,$(src))
CC = gcc
CPPFLAGS=-I./
$(target): $(object)
	$(CC) -o $@ $^
%.o:%.c
	$(CC) -c $< $(CPPFLAGS)
.PHONY:clean
clean:
	rm -f $(object) $(target)
		
```

– make -f : -f执行一个makefile文件名称, 使用make执行指定的makefile: make -f mainmak

# 3 IO函数

## 3.1 c语言操作文件相关问题:

使用fopen函数打开一个文件, 返回一个FILE* fp, 这个指针指向的结构体有三个重要的成员.

Ø 文件描述符: 通过文件描述可以找到文件的inode, 通过inode可以找到对应的数据块

Ø 文件指针: 读和写共享一个文件指针, 读或者写都会引起文件指针的变化

Ø 文件缓冲区: 读或者写会先通过文件缓冲区, 主要目的是为了减少对磁盘的读写次数, 提高读写磁盘的效率.

![image-20210123190550271](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210123190550271.png)



![image-20210123195754175](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210123195754175.png)

虚拟地址空间:
	进程的虚拟地址空间分为用户区和内核区, 其中内核区是受保护的, 用户是不能够对其进行读写操作的;
	内核区中很重要的一个就是进程管理, 进程管理中有一个区域就是PCB(本质是一个结构体);
	PCB中有文件描述符表, 文件描述符表中存放着打开的文件描述符, 涉及到文件的IO操作都会用到这个文件描述符.



> 作业: 
>
> 将add.c sub.c mul.c divd.c编写makefile文件生成库文件;-----makefile的名字为mathmak, 并编写main.c主程序调用库文件的makefile, 名字为mainmak.



## 3.2 c++中文件操作:

### 3.2.1 读文件

```c++
#include "fstream"

std::fstream ifs;

void read(){
	ifs.open("./tujiao.txt", ios::in);
    if(!ifs.is_open())
    {
        cout << "file not open" << endl;
    }
    while(getline(ifs, buf))
    {
        vector<float> tokens = Split(buf,',');
        motor_data1.push_back(tokens);
        i++;
    }
    ifs.close();
}
```



# 4 Linux下的进程

进程间不共享全局变量，共享文件。

全局变量：读时共享，写时复制。

文件：父子进程可以共享文件描述符。

## 4.1 并发和并行

- 并发，在一个时间段内, 是在同一个cpu上, 同时运行多个程序。
  - 如：若将CPU的1S的时间分成1000个时间片，每个进程执行完一个时间片必须无条件让出CPU的使用权，这样1S中就可以执行1000个进程。

- 并行性指两个或两个以上的程序在同一时刻发生(需要有多颗，与cpu核心数有关)。

## 4.2 进程状态(面试考)

- 进程基本的状态有5种。
- 分别为**初始态，就绪态，运行态，挂起态与终止态**。其中初始态为进程准备阶段，常与就绪态结合来看。

![image-20210204165631079](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210204165631079.png)

## 4.2 fork函数

```c
pid_t pid = fork();   // 创建子进程
if(pid < 0)
{
    printf("fork error");
}
if(pid > 0)
{
    printf("father pid %d",getpid());
}
if(pid == 0)
{
    printf("child pid");
}
```

**注意：对于全局变量读时共享，写时赋值**

## 4.2 exec函数族

> 有的时候需要在一个进程里面执行其他的命令或者是用户自定义的应用程序，此时就用到了exec函数族当中的函数。
>
> 使用方法一般都是在父进程里面调用fork创建处子进程，然后在子进程里面调用exec函数。

- 函数原型: int execl(const char *path, const char *arg, ... /* (char  *) NULL */);

- 参数介绍：
  - path: 要执行的程序的绝对路径
  - 变参arg: 要执行的程序的需要的参数
  - arg:占位，通常写应用程序的名字
  - arg后面的: 命令的参数
  - 参数写完之后: NULL
- 返回值：若是成功，则不返回，不会再执行exec函数后面的代码；若是失败，会执行execl后面的代码，可以用perror打印错误原因。
- execl函数一般执行自己写的程序。

> 总结：
>
> exec函数是用一个新程序替换了当前进程的代码段、数据段、堆和栈；原有的进程空间没有发生变化，并没有创建新的进程，进程PID没有发生变化。

函数练习

```c
#include "stdio.h"
#include "stdlib.h"
#include "unistd.h"
#include "sys/types.h"

int main()
{
    pid_t pid = fork();

    if(pid < 0)
    {
        printf("fork error");
        return -1;
    }
    if(pid > 0)
    {
        printf("father: pid == [%d],fpid == [%d]\n",getpid(),getppid());
    }
    if(pid == 0)
    {
        printf("child: pid == [%d],fpid == [%d]\n",getpid(),getppid());
        execlp("ls","ls","-l",NULL);
        // execlp("./1-fork","1-fork",NULL);
        // execl("./test","test","hello",NULL);
 		// execlp("./test","test","hello",NULL);
        perror("execl error");
    }
    sleep(1);
    return 1;
}

```

## 4.3 进程回收函数（wait/waitpid）

僵尸进程：进程终止，父进程尚未回收，子进程残留资源（PCB）被存放于内核中，变成僵尸进程。

孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。

- 函数原型：
  - **pid_t wait(int *status);**
- 函数作用：
  - 阻塞并等待子进程退出 
  - 回收子进程残留资源 
  - 获取子进程结束状态(退出原因)。
- 返回值：
  - 成功：清理掉的子进程ID；
  - 失败：-1 (没有子进程)
- status参数：子进程的退出状态 -- 传出参数
  - WIFEXITED(status)：为非0    → 进程正常结束
  - WEXITSTATUS(status)：获取进程退出状态 
  - WIFSIGNALED(status)：为非0 → 进程异常终止
  - WTERMSIG(status)：取得进程终止的信号编号。

```c
int main()
{
   	pid_t pid = fork();
    
   	if(pid < 0)
	{
		printf("fork error");
		return -1;
	}
	else if(pid > 0)
	{
		printf("father pid == [%d]\n",getpid());
		int status;
		pid_t wpid = wait(&status);
		printf("wpid == [%d]\n",wpid);
	    	if(wpid > 0)	
		{
			if(WIFEXITED(status))
			{
				printf("child exit noemal,status == [%d]\n",WEXITSTATUS(status));
			}
			else if(WIFSIGNALED(status))
			{
				printf("child exit signel,signo == [%d]\n",WTERMSIG(status));
			}
		}
	}
	if(pid == 0)
	{
		printf("child: pid == [%d],fpid == [%d]\n",getpid(),getppid());  
		sleep(200);
		
		return 9;
	}
	sleep(1);

	return 1;
}
```

- 函数原型：
  - **pid_t waitpid(pid_t pid, int *status, in options);**
- 函数作用
  - 同wait函数
- 函数参数：
- pid：
  - pid = -1 等待任一子进程。与wait等效。
  - pid > 0 等待其进程ID与pid相等的子进程。
  - pid = 0 等待进程组ID与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进程在同一个进程组的进程。
  - pid < -1 等待其组ID等于pid的绝对值的任一子进程。(适用于子进程在其他组的情况)
- status: 子进程的退出状态，用法同wait函数。
- options：设置为WNOHANG，函数非阻塞，设置为0，函数阻塞。
- 函数返回值
  - \>0：返回回收掉的子进程ID；
  - -1：无子进程
  - =0：参3为WNOHANG，且子进程正在运行。

```c
int main()
{
   	pid_t pid = fork();
    
   	if(pid < 0)
	{
		printf("fork error");
		return -1;
	}
	else if(pid > 0)
	{
		printf("father pid == [%d]\n",getpid());
		int status;
		//pid_t wpid = waitpid(pid, &status, 0);
		while(1)
		{
			// -1表示等待任意子进程，WNOHANG表示不阻塞
			pid_t wpid = waitpid(-1, &status, WNOHANG); 
			// printf("wpid == [%d]\n",wpid);
			if(wpid > 0)	
			{
				if(WIFEXITED(status))
				{
					printf("child exit noemal,status == [%d]\n",WEXITSTATUS(status));
				}
				else if(WIFSIGNALED(status))
				{
					printf("child exit signel,signo == [%d]\n",WTERMSIG(status));
				}
			}
			else if (wpid == 0)
			{
				// printf("child is living, wpid==[%d]\n",wpid);
			}
			else if (wpid == -1)
			{
				printf("no child is living,wpid == [%d]\n",wpid);
				break;
			}
		}
		
	}
	if(pid == 0)
	{
		printf("child: pid == [%d],fpid == [%d]\n",getpid(),getppid());  
		sleep(1);
		
		return 9;
	}
	sleep(1);

	return 1;
}
```

**注意：调用一次wait或waitpid函数只能回收一个子进程。**

# 5 进程间通信(管道及共享内存)

1. 熟练使用pipe进行父子进程间通信

2. 熟练使用pipe进行兄弟进程间通信

3. 熟练使用fifo进行无血缘关系的进程间通信
4. 使用mmap进行有血缘关系的进程间通信
5. 使用mmap进行无血缘关系的进程间通信

**基本概念（IPC）**:InterProcess Communication

- Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到。

- 两个进程要想完成数据交换，必须通过内核。

- 一个进程将数据写入内核，然后另一个进程从内核读走数据。

## 5.1 进程间通信的方式

文件，管道，信号，共享内存，消息队列，套接字等。

常用的有：

1. 管道（使用最简单）
2. 信号（开销最小）
3. 共享映射区（无血缘关系）
4. 本地套接字（最稳定）

## 5.2 无名管道

管道是一种最基本的IPC机制，应用于有血缘关系的进程间通信，完成数据传递。调用pipe函数创建一个管道。

管道的特质：

- 管道的本质是一块内核缓冲区。
- 有两个文件描述符引用，一个表示读端，一个表示写端。
- 规定数据从管道的写端流入管道，从读端流出。
- 当两个进程都终结时，管道也自动消失。
- 管道的读端和写端都默认是阻塞的。

管道的原理：

- 管道的是指是内核缓冲区，内部使用环形队列实现。
- 默认缓冲区大小为4K，可以使用ulimit -a命令获取大小。
- 数据流向单向（若想双向需要两个管道）

### 5.2.1 管道的读写行为

- 读操作
  - 有数据
    - read正常读，返回读出的字节数
  - 无数据
    - 写端全部关闭
    - read接触阻塞，返回0，相当于读文件读到了尾部。
- 写操作
  - 读端全部关闭
    - 管道破裂，进程终止，内核给当前进程发SIGPIPE信号
  - 读端没全部关闭
    - 缓冲区写满了，发生write阻塞。
    - 缓冲区没满，继续write。

### 5.2.2 如何设置管道非阻塞

默认情况下，管道的读写两端都是阻塞的，若要设为非阻塞：

1. int flags = fcntl(fd[0],F_GETFL);
2. flags |= O_NONBLOCK;
3. fcntl(fd[0],F_SETFL,flags);

若读端设置为非阻塞：

1. 写端没关闭，管道中没有数据可读，返回-1。
2. 写端没关闭，管道中有数据，返回实际读到的字节数。
3. 写端已关闭，管道中有数据，返回实际读到的字节数。
4. 写端已关闭，管道中没数据，则返回0。

**查看管道缓冲区大小**

命令：ulimit -a

函数：long fpathconf(int fd, int name);   **long fpathconf(fd[0], _PC_PIPE_BUF); **

## 5.3 命名管道

FIFO常被称为命名管道，以区分pipe。管道（pipe）只能用于有血缘关系的进程间通信。但是通过FIFO，不相关的进程也能交换数据。

FIFO是Linux基础文件类型中的一种（文件类型为p，可通过ls -l查看文件类型）。但FIFO文件在磁盘上没有数据块，文件大小为0，仅仅用来标识内核中一条通道。进程可以打开这个文件进行read/write，实际上是在读写内核缓冲区，这样就实现了进程间通信。

### 5.3.1 FIFO完成两个进程间通信的思路

进程A：

- 创建fifo文件，mkfifo命令或者mkfifo函数。
- 打开FIFO文件，open fifo文件获得文件描述符。
- write(fd, "xxxx", ...);写fifo文件。
- close(fd); 关闭FIFO文件。

进程B：

1. 打开fifo文件，获得文件描述符。
2. 读fifo文件，read(fd, buf, sizeof(buf));
3. 关闭fifo文件，close(fd);

### 5.3.2 代码段

write代码:

```c
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "unistd.h"
#include "sys/types.h"
#include "sys/stat.h"
#include "fcntl.h"

int main()
{
    // 创建fifo
    int ret = access("./myfifo", F_OK);
    if(ret != 0)
    {
        int ret = mkfifo("./myfifo", 0777);
        if(ret < 0)
        {
            perror("mkfifo error");
            return -1;
        }
    }

    // 打开文件
    int fd = open("./myfifo", O_RDWR);
    if(fd < 0)
    {
        perror("open myfifo error");
    }

    while (1)
    {
        char str[64];

        fgets(str, 64, stdin);
        // 写fifo文件
        write(fd, str, strlen(str));
        // sleep(1);
    }

    // 关闭fifo文件
    close(fd);

    getchar();

    return EXIT_SUCCESS;
}
```

read代码：

```c
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "unistd.h"
#include "sys/types.h"
#include "sys/stat.h"
#include "fcntl.h"

int main()
{
    // 打开文件
    int fd = open("./myfifo", O_RDWR);
    if(fd < 0)
    {
        perror("open myfifo error");
    }

    // 读fifo文件
    char buf[64];
    memset(buf, 0x00, sizeof(buf));
    int n = 0;
    while(1)
    {
        n = read(fd, buf, sizeof(buf));
        printf("n:%d,s:%s\n",n, buf); 
    }

    return EXIT_SUCCESS;
}
```

## 5.4 内存映射区(mmap)

### 5.4.1 相关函数

```c
void *mmap(void *addr, size_t length, int port, int flags, int fd, off_t offset);
```
**作用：**建立存储映射区。

**参数：**

- addr：一般传NULL，表示让内核去指定一个内存起始地址。
- length：文件大小；
  - lseek或者stat函数得到。
- prot：
  - PROT_READ  PROT_WRITE  PROT_READ|PROT_WRITE  
- flags：
  - MAP_SHARED：对映射区的修改会反映到文件中（可以对文件进行修改）。
  - MAP_PRIVATE：对映射区的修改不会对文件产生影响。
- fd：打开文件描述符
  - fd = open();
- offset：从文件的哪个位置开始映射，一般传0。

**返回值：**映射区首地址。

```c
int munmap(void *addr, size_t length);
```
**作用：**释放由mmap创建的内存映射区。
**返回值：**

- 成功：返回0.
- 失败：返回1.

**参数：**

- addr：调用mmap函数成功返回的映射区首地址。

- length：映射区大小。（mmap函数第二个参数）。

### 5.4.2 代码演示

```c
// 使用mmap进行父子进程间的通信。
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "unistd.h"
#include "sys/types.h"
#include "sys/wait.h"
#include "fcntl.h"
#include "sys/stat.h"
#include "sys/mman.h"

int main()
{
    int fd = open("./test.log", O_RDWR);
    // 使用mmap函数建立共享映射区
    int len = lseek(fd, 0, SEEK_END);

    void *addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(addr == MAP_FAILED)
    {
        perror("mmap error");
    }

    // 创建子进程
	pid_t pid = fork();
    
    if(pid < 0)
	{
		printf("fork error");
		return -1;
	}
	if(pid > 0)
	{
		// printf("father: pid == [%d],fpid == [%d]\n",getpid(),getppid());
        memcpy(addr, "[hello zhang HAI TAO]", strlen("[hello zhang HAI TAO]"));	
	}
	if(pid == 0)
	{
		// printf("child: pid == [%d],fpid == [%d]\n",getpid(),getppid());
        sleep(1);
        char *p = (char*)addr;
        printf("%s", p);
	}
	// sleep(1);

	return 1;
}
```

```c
// 使用mmap进行不同进程间的通信。（写）
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "unistd.h"
#include "sys/types.h"
#include "sys/wait.h"
#include "fcntl.h"
#include "sys/stat.h"
#include "sys/mman.h"

int main()
{
    int fd = open("./test.log", O_RDWR);
    // 使用mmap函数建立共享映射区
    int len = lseek(fd, 0, SEEK_END);

    void *addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(addr == MAP_FAILED)
    {
        perror("mmap error");
    }

	memset(addr, 0x00, len);
	memcpy(addr, "[hello 123456]", strlen("[hello 123456]"));	

	return EXIT_SUCCESS;
}
```

```c
// 使用mmap进行不同进程间的通信。（读）
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "unistd.h"
#include "sys/types.h"
#include "sys/wait.h"
#include "fcntl.h"
#include "sys/stat.h"
#include "sys/mman.h"

int main()
{
    int fd = open("./test.log", O_RDWR);
    // 使用mmap函数建立共享映射区
    int len = lseek(fd, 0, SEEK_END);

    void *addr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(addr == MAP_FAILED)
    {
        perror("mmap error");
    }

    char *p = (char*)addr;
    printf("%s", p);	

	return EXIT_SUCCESS;
}
```

### 5.4.3 mmap函数建立匿名映射

```c
  // 使用mmap进行父子进程间的通信。
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "unistd.h"
#include "sys/types.h"
#include "sys/wait.h"
#include "fcntl.h"
#include "sys/stat.h"
#include "sys/mman.h"

int main()
{
    void *addr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
    if(addr == MAP_FAILED)
    {
        perror("mmap error");
    }

    // 创建子进程cd 
	pid_t pid = fork();
    
    if(pid < 0)
	{
		printf("fork error");
		return -1;
	}
	if(pid > 0)
	{
        memcpy(addr, "[hello zhang HAI TAO]\n", strlen("[hello zhang HAI TAO]\n"));	
		wait(NULL);
	}
	if(pid == 0)
	{
        sleep(1);
        char *p = (char*)addr;
        printf("%s", p);
	}

	return 1;
}
```

# 6 进程间通信(信号)

## 6.1 学习目标

- 了解信号中的基本概念
- 熟练使用信号相关的函数
- 参考文档使用信号集操作相关函数
- 熟练使用信号捕捉函数signal
- 熟练使用信号捕捉函数sigaction
- 熟练掌握使用信号完成子进程的回收

## 6.2 信号的机制

### 6.2.1 基本概念

**信号的概念：**

信号是信息的载体，Linux/UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。

**信号的机制：**

进程A给进程B发送信号，进程B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕后再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。

**每个进程收到的所有信号，都是由内核负责发送的。(用户->内核->用户)**

### 6.2.2 信号的状态

信号有三种状态：产生、未决和递达。

- **信号的产生**
  - 按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\
  - 系统调用产生，如：kill、raise、abort
  - 软件条件产生，如：定时器alarm
  - 硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)
  - 命令产生，如：kill命令

- 未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 
- 递达：递送并且到达进程。

**信号的处理方式：**

1. 执行默认动作。
2. 系统调用产生，如：kill、raise、abort。
3. 软件条件产生，如：定时器alarm。
4. 硬件异常产生，如：非法访问内存(段错误)、除0（浮点数例外）、内存对齐出错（总线错误）。
5. 命令产生，如：kill命令。

​    Linux内核的进程控制块PCB是一个结构体，task_struct，除了包含进程id，状态，工作目录，用户id，组id，文件描述符，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。

- **阻塞信号集：**将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，在收到该信号，该信号的处理将推后（解除屏蔽后）。
- **未决信号集：**1.信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回0.这一时刻往往非常短暂。2.信号产生后由于某些原因（主要是阻塞）不能抵达。

**信号的编号：**

查看所有信号的指令：kill -l

**信号四要素：**

1.编号 2.名称 3.事件 4.默认处理动作 （通过man 7 singal查看）。

**相关函数**

```c
int kill(pid_t pid, int sig);
```

成功返回0，失败返回-1.

pid>0：发送信号给指定进程。

pid = 0：发送信号给与调用kill函数同一进程组的所有进程。

pid = -1：发送信号给进程有权限发送的系统中所有进程。

**alarm函数：**

作用：设置定时器，在指定second后，内核会给当前进程发送14）SIGALRM信号。

```c
unsigned int alarm(unsigned int seconds);
```

返回0或剩余的秒数，无失败。

**setitimer函数：**

作用：设置定时器。可代替alarm函数。精度为微秒，可实现周期性定时。

```c
int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
```

参数：

- which：指定定时方式。1.自然定时：ITIMER_REAL->14)SIGVTAALRM。2.虚拟空间定时：（用户空间）3.运行时计时：（用户+内核）。

## 6.3 信号集操作

内核通过读取未决信号集来判断信号是否被处理。信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。

### 6.3.1 信号集设定

```c
sigset_t set;
int sigemptyset(sigset_t *set);	将某个信号集清0
int sigfillset(sigset_t *set);	将某个信号集置1
int sigaddset(sigset_t *set, int signum);	将某个信号加入信号集
int sigdelset(sigset_t *set, int signum);	将某个信号清出信号集
int sigismenber(const sigset_t *set, int signum);	判断某个信号是否在信号集中。
```

**sigpromask函数：**

用来屏蔽信号、解除屏蔽。其本质，读取或修改进程的信号屏蔽字（PCB中）;

```c
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

参数：

- set：传入参数，是一个位图，set中哪个位置1，就表示屏蔽哪个信号。
- oldset：传出参数，保存旧的信号屏蔽集。
- how：参数取值：假设当前信号屏蔽字为mask。
  - SIG_BLOCK：set表示将要屏蔽的信号。相当于mask=mask|set。
  - SIG_UNBLOCK：set表示需要解除屏蔽的信号。相当于mask=mask&~set。
  - SIG_SETMASK：set表示用于替代原始屏蔽集的新屏蔽集。

**sigpending函数：**

读取当前进程的未决信号集

```c
int sigpending(sigset_t *set);	//set传出参数。
```

练习：编写程序。把所有常规信号的未决状态打印至屏幕。

# 7 线程

## 7.2 线程同步

线程同步，指一个线程发出某一功能调用时，在没有得到结果前，该调用不返回。同时其他进程为保证数据一致性，不能调用该功能。

**线程同步例子**

创建两个子线程，让两个线程共享一个全局变量int num，然后让每个线程数5000词



# 8 tcp/ip协议

## 8.1 常见协议

- 传输层：TCP/UDP协议
- 应用层：HTTP协议，FTP协议。
- 网络层：IP协议，ICMP协议，IGMP协议。
- 网络接口层：ARP协议，RARP协议。

TCP[传输控制协议](http://baike.baidu.com/view/544903.htm)（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的[传输层](http://baike.baidu.com/view/239605.htm)通信协议。

UDP用户数据报协议（User Datagram Protocol）是[OSI](http://baike.baidu.com/view/113948.htm)参考模型中一种无连接的[传输层](http://baike.baidu.com/view/239605.htm)协议，提供面向事务的简单不可靠信息传送服务。

HTTP[超文本传输协议](http://baike.baidu.com/view/468465.htm)（Hyper Text Transfer Protocol）是[互联网](http://baike.baidu.com/view/6825.htm)上应用最为广泛的一种[网络协议](http://baike.baidu.com/view/16603.htm)。

FTP文件传输协议（File Transfer Protocol）

IP协议是[因特网](http://baike.baidu.com/view/1706.htm)互联协议（Internet Protocol）

ICMP协议是Internet控制[报文](http://baike.baidu.com/view/175122.htm)协议（Internet Control Message Protocol）它是[TCP/IP协议族](http://baike.baidu.com/view/2221037.htm)的一个子协议，用于在IP[主机](http://baike.baidu.com/view/23880.htm)、[路由](http://baike.baidu.com/view/18655.htm)器之间传递控制消息。

IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。

[ARP](http://baike.baidu.com/view/32698.htm)协议是正向[地址解析协议](http://baike.baidu.com/view/149421.htm)（Address Resolution Protocol），通过已知的IP，寻找对应主机的[MAC地址](http://baike.baidu.com/view/69334.htm)。

[RARP](http://baike.baidu.com/view/32772.htm)是反向地址转换协议，通过MAC地址确定IP地址。

## 8.2 分层模型

OSI是Open System Interconnection的缩写, 意为开放式系统互联. [国际标准化组织](https://baike.so.com/doc/5340499-5575942.html)(ISO)制定了OSI模型, 该模型定义了不同计算机互联的标准, 是设计和描述计算机网络通信的基本框架.

网络分层 OSI 7层模型: 物数网传会表应 

Ø 物理层---双绞线，光纤（传输介质），将模拟信号转换为数字信号

Ø 数据链路层---数据校验，定义了网络传输的基本单位-帧 

Ø 网络层---定义网络，两台机器之间传输的路径选择点到点的传输

Ø 传输层---传输数据 TCP，UDP，端到端的传输 

Ø 会话层---通过传输层建立数据传输的通道. 

Ø 表示层---编解码，翻译工作.

Ø 应用层---为客户提供各种应用服务，email服务，ftp服务，ssh服务 



**物数网传会表应**

![1](D:\work_station\黑马c++\git\linux_study\pic\1.png)

![2](D:\work_station\黑马c++\git\linux_study\pic\2.png)

![3](D:\work_station\黑马c++\git\linux_study\pic\3.png)



通过IP地址来确定网络环境中的唯一的一台主机;

主机上使用端口号来区分不同的应用程序.

IP+端口唯一确定唯一一台主机上的一个应用程序.

 

## 8.3 socket通信编程

发送端：数据层层打包。

接收端：数据层层解包。

### 8.3.1 服务端开发流程

- 创建soket，返回一个文件描述符lfd = socket()。---该文件描述符用于监听客户端链接。
- 将lfd和IP PORT进行绑定---bind();
- 将lfd有主动变为被动监听---listen();
- 接受一个新的连接，得到一个文件描述符cfd---accept();---该文件描述符用于和客户端进行通信的。
- while(1){ 接受数据(read/recv)； 发送数据(write/send)； }
- 关闭文件描述符---close(lfd),close(cfd);



### 8.3.2 客户端开发流程

- 创建socket，返回一个文件描述符cfd；
- 连接服务器---connect();
- while(1){ //发送数据---write或者send  //接收数据---read或者recv}
- close(cfd);



## 8.4 三次握手四次挥手



思考：为什么TCP是面向连接

**三次握手：建立连接需要三次握手。**

1、-> SYN, 2000(0), <mss 1024>

2、<- SYN, 5000(0), ACK(2001), <mss 1024>

3、-> ACK(5001);

**数据传输过程**

4、-> seq: 2001(20);

5、<- seq: 5001(50), ACK(2021)

6、-> ACK(5051)

**四次挥手：断开连接需要四次挥手。**

7、  -> FIN  (2021), 

8、  <- ACK (2022)

9、  <- FIN  (5051)

10、-> ACK (5052)



# 9 git操作相关

```c++
git add . 
git commit -m "first commit" 
git remote rm origin 
git remote add origin .git 
git branch -M main               
git push -u origin main  

// 本地代码未修改，只有master分支，直接更新
git pull
```

  



# 附录（面经总结）

### 进程间通信方式 

  （1）. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 
  （2）. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 
  （3）消息队列MessageQueue：消息队列是由消息的[链表]()，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 
  （4）共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 
  （5）信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 
  （6） 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 
  （7）信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

### 线程间通信方式

（1）互斥锁（2）信号（3）信号量



### #include<> include" "区别 

   （1）引用的头文件不同  

   \#include< >引用的是编译器的类库路径里面的头文件。  

  

 \#include“ ”引用的是你程序目录的相对路径中的头文件。 

  

 （2）用法不同 

 \#include< >用来包含标准头文件(例如stdio.h或stdlib.h). 

 \#include“ ”用来包含非标准头文件。 

 （3）调用文件的顺序不同 

 \#include< >编译程序会先到标准函数库中调用文件。 

  \#include“ ”编译程序会先从当前目录中调用文件。 

  

  （4）预处理程序的指示不同 

 \#include< >指示预处理程序到预定义的缺省路径下寻找文件。 

  \#include“ ”指示预处理程序先到当前目录下寻找文件，再到预定义的缺省路径下寻找文件。



### C/C++内存分区   

-  1、栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等 
-  其操作方式类似于数据结构中的栈。 
-  2、堆区（heap） — 一般由程序员分配释放，若程序员不释放，程序结束时可能由 
-  OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于[链表]()。 
-  3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化 
-  的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻 
-  的另一块区域。程序结束后由系统释放。 
-  4、文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。 
-  5、程序代码区—存放函数体的二进制代码。

作者：爱打球的程小员许乔丹
链接：https://www.nowcoder.com/discuss/441310?type=all&order=time&pos=&page=20&channel=-1&source_id=search_all_nctrack
来源：牛客网



# 第一章进程线程 

##  1.1 进程线程的基本概念 

 **1.1.1 什么是进程，线程，彼此有什么区别⭐⭐⭐⭐⭐** 

进程——资源分配的最小单位，线程——程序执行的最小单位。

线程进程的区别体现在几个方面：

- 第一：因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。
- 第二：体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。
- 属于同一个进程的所有线程共享该进程的所有资源，包括文件描述符。而不同过的进程相互独立。
- 线程又称为轻量级进程，进程有进程控制块，线程有线程控制块；
- 线程必定也只能属于一个进程，而进程可以拥有多个线程而且至少拥有一个线程；
- 第四：体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。

 **1.1.2多进程、多线程的优缺点⭐⭐⭐⭐** 

多进程：系统安全性高，开销大，程序结构复杂。

多线程：安全系数较低（一个线程死掉，往往整个进程崩溃），效率高。

 **1.1.3什么时候用进程，什么时候用线程⭐⭐⭐** 

进程与线程的选择取决以下几点：

1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。

2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应

3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；

4、并行操作时使用线程，如C/S[架构](http://lib.csdn.net/base/architecture)的服务器端并发线程响应用户的请求；

5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。

 **1.1.4多进程、多线程同步（通讯）的方法⭐⭐⭐⭐⭐** 

**进程间通讯：**
管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

有名管道 (FIFO) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

信号量( semophore ) ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

信号 ( sinal ) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

共享内存( sharedmemory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

**线程通讯：**
互斥锁提供了以排他方式防止数据结构被并发修改的方法。
读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
信号机制(Signal)： 类似进程间的信号处理

 **1.1.5进程的空间模型⭐⭐⭐⭐** 

![4](D:\work_station\黑马c++\git\linux_study\pic\4.png)

1、内核区：用户代码不可见的区域，页表就存放在这个区域中。

2、用户区：

    a、代码段：只可读，不可写，程序代码段。
    
    b、数据段：保存全局变量，静态变量的区域。
    
    c、堆区：就是动态内存，通过malloc，new申请内存，有一个堆指针，可以通过brk系统调用调整堆指针。
    
    d、文件映射区域：通过mmap系统调用，如动态库，共享内存等映射物理空间的内存区域。可以单独释放，不会产生内存碎片。
    
    e、栈区：用于维护函数调用的上下文空间，用ulimit -s 查看。一般默认为8M

 **1.1.6进程线程的状态转换图 什么时候阻塞，什么时候就绪⭐⭐⭐** 

概念描述：
**就绪状态 ：**一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。
**执行状态：**当一个进程在处理机上运行时，则称该进程处于运行状态。
**阻塞状态**：一个进程正在等待某一事件发生（例如请求I／O而等待I／O完成等）而暂时仃止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。
**挂起状态：**由于IO的速度慢于CPU的运算速度，经常出现CPU等待I/O的情况。这时OS需要将主存中的进程对换至外存。在进程行为模式中需要增加一个新的挂起（suspend）状态。当内存中所有进程阻塞时，OS可将一进程置为挂起态并交换到外存，再调入另一个进程执行。
**新建状态：**进程刚创建，但还不能运行，OS还没有把它加到可执行进程组中，通常是还没有加载到主存中的新进程。
**退出状态：**OS从可执行进程组中释放出的进程，或者是因为它自身停止了，或者是因为某种原因被取消。进程不在适合执行，但与作业相关的表和其它信息临时被OS保留起来，为其他程序提供所需信息。
**活跃就绪：**指进程在主存并旦可被调度的状态。
**静止就绪：**指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起态进程具有更高的优先级，系统将把挂起就绪态进程调回主存并转换为活跃就绪。
**活跃阻塞：**指进程在主存中。一旦等待的事件产生，便进入活跃就绪状态。
**静止阻塞：**指进程对换到辅存时的阻塞状态。一旦等待的事件产生，便进入静止就绪状态。

 **1.1.7父进程、子进程的关系以及区别⭐⭐⭐⭐** 

1、父子进程之间的关系
关于资源：子进程得到的是除了代码段是与父进程共享的意外，其他所有的都是得到父进程的一个副本，子进程的所有资源都继承父进程，得到父进程资源的副本，既然为副本，也就是说，二者并不共享地址空间。，两个是单独的进程，继承了以后二者就没有什么关联了，子进程单独运行。（采用写时复制技术）
关于文件描述符：继承父进程的文件描述符时，相当于调用了dup函数，父子进程共享文件表项，即共同操作同一个文件，一个进程修改了文件，另一个进程也知道此文件被修改了。

2、线程与进程之间的关系
一个进程的线程之间共享由进程获得的资源，但线程拥有属于自己的一小部分资源，就是栈空间，保存其运行状态和局部自动变量的。堆是堆，栈是栈。栈可以叫做：堆栈，栈，栈和堆栈指的都是stack，只是叫法不一样。而堆就只能叫做堆。在线程中new出来的空间占的是进程的资源，也就是说是占用的堆资源(heap)。

 **1.1.9一个进程可以创建多少线程，和什么有关⭐⭐** 

理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。怎么设置呆会儿再说。

##  1.2 并发，同步，异步，互斥，阻塞，非阻塞的理解 

 **1.2.1什么是线程同步和互斥⭐⭐⭐⭐⭐** 

互斥：指在某一时刻指允许一个进程运行其中的程序片，具有排他性和唯一性。
对于线程A和线程B来讲，在同一时刻，只允许一个线程对临界资源进行操作，即当A进入临界区对资源操作时，B就必须等待；当A执行完，退出临界区后，B才能对临界资源进行操作。
同步：指的是在互斥的基础上，实现进程之间的有序访问。假设现有线程A和线程B，线程A需要往缓冲区写数据，线程B需要从缓冲区读数据，但他们之间存在一种制约关系，即当线程A写的时候，B不能来拿数据；B在拿数据的时候A不能往缓冲区写，也就是说，只有当A写完数据（或B取走数据），B才能来读数据（或A才能往里写数据）。这种关系就是一种线程的同步关系。

 **1.2.2线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？⭐⭐⭐⭐** 

同步是个过程，阻塞是线程的一种状态。多个线程操作共享变量时可能会出现竞争。这时需要同步来防止两个以上的线程同时进入临界区，在这个过程中，后进入临界区的线程将阻塞，等待先进入的线程走出临界区。
线程同步不一定发生阻塞！！！线程同步的时候，需要协调推进速度，互相等待和互相唤醒会发生阻塞。

 **1.2.3并发，同步，异步，互斥，阻塞，非阻塞的理解⭐⭐⭐⭐⭐** 

- 同步(synchronous)：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。
- 异步(asynchronous)：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。
- 阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。
- 非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

##  1.3 孤儿进程、僵尸进程、守护进程的概念 

 **1.3.1基本概念⭐⭐⭐⭐⭐** 

1.孤儿进程

如果父进程先退出,子进程还没退出那么子进程将被 托孤给init进程,这是子进程的父进程就是init进程(1号进程).其实还是很好理解的.

2.僵尸进程 

如果一个进程已经终止了,但是其父进程还没有获取其状态,那么这个进程就称之为僵尸进程.僵尸进程还会消耗一定的系统资源,并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息.一旦父进程得到想要的信息,僵尸进程就会结束.

3.守护进程

守护进程就是在后台运行,不与任何终端关联的进程,通常情况下守护进程在系统启动时就在运行,它们以root用户或者其他特殊用户(apache和postfix)运行,并能处理一些系统级的任务.习惯上守护进程的名字通常以d结尾(sshd),但这些不是必须的.

 **1.3.2如何创建守护进程：⭐⭐** 

创建守护进程的步骤

- 调用fork(),创建新进程,它会是将来的守护进程.
- 在父进程中调用exit,保证子进程不是进程组长
- 调用setsid()创建新的会话区
- 将当前目录改成跟目录(如果把当前目录作为守护进程的目录,当前目录不能被卸载他作为守护进程的工作目录)
- 将标准输入,标注输出,标准错误重定向到/dev/null

 **1.3.3正确处理僵尸进程的方法⭐⭐⭐⭐** 

signal()函数的声明sighandler_t signal(int signum, sighandler_t handler),我们可以得出,signal函数的第一个函数是Linux支持的信号,第二个参数是对信号的操作 ,是系统默认还是忽略或捕获.我们这是就可以知道signal(SIGCHLD,SIG_IGN)是选择对子程序终止信号选择忽略,这是僵尸进程就是交个内核自己处理,并不会产生僵尸进程.

signal(SIGCHLD,SIG_IGN),加上就不会出现僵尸进程了.

#  第二章C/C++高频面试题 

##  2.1 c和[c++]()区别、概念相关面试题 

 **2.1.1 new和malloc的区别⭐⭐⭐⭐⭐** 

0.       属性

new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。

1.       参数

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

2.       返回类型

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

3.       分配失败

new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

4.      自定义类型

         new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

         malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

5.      重载

C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

6.       内存区域

new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

 **2.1.2 malloc的底层实现⭐⭐⭐⭐** 

 **2.1.3在1G内存的计算机中能否malloc(1.2G)？为什么？⭐⭐** 

答：是有可能申请1.2G的内存的。

解析：回答这个问题前需要知道malloc的作用和原理，应用程序通过malloc函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接关系，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。

 **2.1.4指针与引用的相同和区别；如何相互转换？⭐⭐⭐⭐⭐** 

相同

- 都是地址的概念，指针指向某一内存、它的内容是所指内存的地址；引用则是某块内存的别名。

- 从内存分配上看：两者都占内存，程序为指针会分配内存，一般是4个字节；而引用的本质是指针常量，指向对象不能变，但指向对象的值可以变。两者都是地址概念，所以本身都会占用内存。

区别

- 指针是实体，而引用是别名
- 指针和引用的自增（++）运算符意义不同，指针是对内存地址自增，而引用是对值的自增。
- 引用使用时无需解引用(*)，指针需要解引用；（关于解引用大家可以看看这篇博客，传送门）
- 引用只能在定义时被初始化一次，之后不可变；指针可变；
- 引用不能为空，指针可以为空
- “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小，在32位系统指针变量一般占用4字节内存。

 **2.1.5 C语言检索内存情况 内存分配的方式⭐⭐⭐** 

操作系统将C语言代码分为四个区：

1、栈区

2、堆区

3、全局区

4、程序代码区

其中，

栈区：由编译器自动分配释放，存放函数的参数值，局部变量等

堆区：一般由程序员手动分配释放（动态内存的申请与释放），若未手动释放，程序结束时可能由操作系统回收。

全局区：又称静态区，全局变量和静态变量的存储是放在一块儿的，初始化的全局变量和初始化的静态变量是在一块儿区域，未初始化的全局变革两和未初始化的静态变量在相邻的一块区域，该区域由程序结束后由操作系统释放。

程序代码区：存放函数体的二进制代码。


 **2.1.6  extern”C” 的作用⭐⭐⭐** 

我们可以在C++中使用C的已编译好的函数模块，这时候就需要用到extern”C”。也就是extern“C” 都是在c++文件里添加的。

extern在链接阶段起作用（四大阶段：预处理--编译--汇编--链接）。

 **2.1.7头文件声明时加extern定义时不要加 因为extern可以多次声明，但只有一个定义⭐⭐⭐⭐** 

 **2.1.8函数参数压栈顺序，即关于stdcall和cdecl调用方式的理解⭐⭐⭐** 

 **2.1.9重写memcpy()函数需要注意哪些问题⭐⭐** 

 **2.1.10数组到底存放在哪里⭐⭐⭐** 

 **2.1.11  struct和class的区别 ⭐⭐⭐⭐⭐** 

1）默认的继承访问权限。struct是public的，class是private的。

2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。

3）“class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。

 **2.1.12 char和int之间的转换；⭐⭐⭐** 

 **2.1.14  static的用法（定义和用途）⭐⭐⭐⭐⭐** 

1）用static修饰局部变量：使其变为静态存储方式(静态数据区)，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中。

2）用static修饰全局变量：使其只在本文件内部有效，而其他文件不可连接或引用该变量。

3）用static修饰函数：对函数的连接方式产生影响，使得函数只在本文件内部有效，对其他文件是不可见的（这一点在大工程中很重要很重要，避免很多麻烦，很常见）。这样的函数又叫作静态函数。使用静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外也是对函数本身的一种保护机制。

 **2.1.15const常量和#define的区别（编译阶段、安全性、内存占用等） ⭐⭐⭐⭐** 

编译阶段：有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。

安全性：const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。

内存占用：在执行时const定义的只读变量在程序运行过程中只有一份拷贝，存放在静态存储区的只读数据区。#define只在预编译阶段进行字节替换。

 **2.1.16  volatile作用和用法 ⭐⭐⭐⭐⭐** 

语言volatile关键字的作用，volatile影响编译器编译的结果，指出变量是随时可能发生变化的，与volatile变量有关的运算，不要进行编译优化，以免出错，（VC++ 在产生release版可执行码时会进行编译优化，加volatile关键字的变量有关的运算，将不进行编译优化。）。

**多线程下的volatile**
1、概念：线程之间的可见性，一个线程修改的状态对另一个线程可见，也就是一个线程修改的结果，另一个线程马上就能看到。
2、实现原理
当对非volatile变量进行读写的时候，每个线程先从主内存拷贝变量到CPU缓存中，如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。
volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，保证了每次读写变量从朱内存中读，跳过CPU cache这一步，当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。

编译器的优化方式有：将内存变量缓存到寄存器，由于访问寄存器要比访问内存单元快的多。

有时编译器对代码会自动进行优化，该关键字就是让编译器不要进行编译优化。volatile意思是“易变的”“直接存取原始内存地址”。（防止变量改变后被编译器优化一直只读寄存器第一次的值，不变了）

3、多线程下的有些变量是要volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的徐哦呜执行。volatile的意思是让编译器每次操作该变量时一定要存内存中存取，而不是使用已经存在寄存器中的值。

**常用地点：**

中断服务程序中修改的供其它程序检测的变量，需要加volatile；（编译器判断主函数里没有改变该变量，就可能把他优化了，那就拿不到改变后的变量值了）
多任务环境下各任务间共享的标志，应该加volatile； （如多线程）
存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同

**常见问题：**

一个变量可以是const又是volatile，如状态寄存器，只读但是又总是因为各种情况改变
一个指针可以使volatile：如当一个中服务子程序修改一个指向buffer的指针时
在一个平方函数中，自变量是volatile型的，有什么问题：是volatile型，那编译器每次都会去内存拿数据，编译器就会定义两块内存来放不同时刻的同一个变量，但是变量可能会变，那就可能实现不了平方了

 **2.1.17有常量指针 指针常量 常量引用 没有 引用常量⭐⭐⭐** 

 **2.1.18没有指向引用的指针，因为引用是没有地址的，但是有指针的引用⭐⭐⭐** 

 **2.1.19c/[c++]()中变量的作用域⭐⭐⭐⭐⭐** 

作用域规则告诉我们一个变量的有效范围，它在哪儿创建，在哪儿销毁（也就是说超出了作用域）。变量的有效作用域从它的定义点开始，到和定义变量之前最邻近的开括号配对的第一个闭括号。也就是说，作用域由变量所在的最近一对括号确定。

(1) 全局变量：

  全局变量是在所有函数体的外部定义的，程序的所在部分（甚至其它文件中的代码）都可以使用。全局变量不受作用域的影响（也就是说，全局变量的生命期一直到程序的结束）。如果在一个文件中使用extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用这个数据。

(2) 局部变量：

  局部变量出现在一个作用域内，它们是局限于一个函数的。局部变量经常被称为自动变量，因为它们在进入作用域时自动生成，离开作用域时自动消失。关键字auto可以显式地说明这个问题，但是局部变量默认为auto，所以没有必要声明为auto。

(3) 寄存器变量

  寄存器变量是一种局部变量。关键字register告诉编译器“尽可能快地访问这个变量”。加快访问速度取决于现实，但是，正如名字所暗示的那样，这经常是通过在寄存器中放置变量来做到的。这并不能保证将变置在寄存器中，甚至也不能保证提高访问速度。这只是对编译器的一个暗示。

使用register变量是有限制的：(1) 不可能得到或计算register 变量的地址; (2) register变量只能在一个块中声明（不可能有全局的或静态的register变量）。然而可以在一个函数中（即在参数表中）使用register变量作为一个形式参数。

  一般地，不应当推测编译器的优化器，因为它可能比我们做得更好。因此，**最好避免使用关键字register**。

(4) 静态变量

  关键字static有一些独特的意义。通常，函数中定义局部变量在函数中作用域结束时消失。当再次调用这个函数时，会重新创建变量的存储空间，其值会被重新初始化。如果想使局部变量的值在程序的整个生命期里仍然存在，我们可以定义函数的局部变量为static(静态的)，并给它一个初始化。初始化只在函数第一次调用时执行，函数调用之间变量的值保持不变，这种方式，函数可以“记住”函数调用之间的一些信息片断。这也就是所谓的**静态局部变量**，具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只在定义自己的函数体内始终可见。

  我们可能奇怪为什么不使用全局变量。static**局部**变量的优点是在函数范围之外它是不可用的，所以它不可能被轻易改变。这会使错误局部化。

  此外同样存在**静态全局变量**，具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

(5) 外部变量

  extern告诉编译器存在着一个变量和函数，即使编译器在当前的文件中没有看到它。这个变量或函数可能在一个文件或者在当前文件的后面定义。例如extern int i;编译器会知道i肯定作为全局变量存在于某处。当编译器看到变量i的定义时，并没有看到别的声明，所以知道它在文件的前面已经找到了同样声明的i。

(6) const常量

  const告诉编译器这个名字表示常量，不管是内部的还是用户定义的数据类型都可以定义为const。如果定义了某对象为常量，然后试图改变它，编译器将会产生错误。在C++中一个const必须有初始值。

(7) volatile变量

  限定词const告诉编译器“这是不会改变的”(这就是允许编译器执行额外的优化)；而限定词volatile则告诉编译器“不知道何时变化”，防止编译器依据变量的稳定性作任何优化。

  从分配内存空间看：**全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间**

 **2.1.20 [c++]()中类型转换机制？各适用什么环境？dynamic_cast转换失败时，会出现什么情况？⭐⭐⭐** 

**2.1.20 inline（内联）函数。**

inline一般只用于如下情况：

-  一个函数不断被重复调用。
- 函数只有简单的几行，且函数不包含for、while、switch语句。
- 1.内联函数在运行时可调试，而宏定义不可以;
- 2.编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会； 
- 3.内联函数可以访问类的成员变量，宏定义则不能； 
- 内联函数只是给编译器一个建议，编译器不一定会接受这种建议。

##  2.2 继承、多态相关面试题 ⭐⭐⭐⭐⭐ 

 **2.2.1继承和虚继承 ⭐⭐⭐⭐⭐** 

 **2.2.2多态的类，内存布局是怎么样的 ⭐⭐⭐⭐⭐** 

虚继承：如果是虚继承，那么就会为这个类创建一个虚表指针，占用4个字节

多重继承：如果是以虚继承实现的多继承，记得减掉基类的副本

普通继承（含有：空类、虚函数）

 **2.2.3被隐藏的基类函数如何调用或者子类调用父类的同名函数和父类成员变量 ⭐⭐⭐⭐⭐** 

 **2.2.4多态实现的三个条件、实现的原理 ⭐⭐⭐⭐⭐** 

 **2.2.5对拷贝构造函数 深浅拷贝 的理解 拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？⭐⭐⭐** 

 **2.2.6析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？⭐⭐⭐** 

 **2.2.7什么情况下会调用拷贝构造函数（三种情况）⭐⭐⭐** 

 **2.2.8析构函数一般写成虚函数的原因⭐⭐⭐⭐⭐** 

 **2.2.9构造函数为什么一般不定义为虚函数⭐⭐⭐⭐⭐** 

 **2.2.10什么是纯虚函数⭐⭐⭐⭐⭐** 

 **2.2.11静态绑定和动态绑定的介绍⭐⭐⭐⭐** 

 **2.2.12 C++所有的构造函数 ⭐⭐⭐** 

 **2.2.13重写、重载、覆盖的区别⭐⭐⭐⭐⭐** 

 **2.2.14成员作者：爱打球的程小员许乔丹**



# 第三章网络编程 

##  3.1 TCP UDP 

 **3.1.1 TCP、UDP的区别 ⭐⭐⭐⭐⭐** 

 **3.1.2 TCP、UDP的优缺点⭐⭐⭐** 

 **3.1.3 TCP UDP适用场景⭐⭐⭐** 

 **3.1.4 TCP为什么是可靠连接⭐⭐⭐⭐** 

 **3.1.5典型网络模型，简单说说有哪些；⭐⭐⭐** 

 **3.1.6 Http1.1和Http1.0的区别⭐⭐⭐** 

 **3.1.7 URI（统一资源标识符）和URL（统一资源定位符）之间的区别⭐⭐** 

 


##  3.2 三次握手、四次挥手 

 **3.2.1什么是三次握手⭐⭐⭐⭐⭐** 

 **3.2.2为什么三次握手中[客户端]()还要发送一次确认呢？可以二次握手吗？⭐⭐⭐⭐** 

 **3.2.3为什么服务端易受到SYN攻击？⭐⭐⭐⭐** 

 **3.2.4什么是四次挥手⭐⭐⭐⭐⭐** 

 **3.2.5为什么[客户端]()最后还要等待2MSL？⭐⭐⭐⭐** 

 **3.2.6为什么建立连接是三次握手，关闭连接确是四次挥手呢？⭐⭐⭐⭐** 

#  第四章常见[算法]() 

##  4.1 [排序]()[算法]() 

 4.1.1各种[排序]()[算法]()的时间空间复杂度、稳定性⭐⭐⭐⭐⭐ 

 4.1.2各种[排序]()[算法]()什么时候有最好情况、最坏情况（尤其是快排） ⭐⭐⭐⭐ 

 4.1.3冒泡[排序]()⭐⭐⭐⭐ 

 4.1.4选择[排序]()⭐⭐⭐⭐ 

 4.1.5插入[排序]()⭐⭐⭐⭐ 

 4.1.6希尔[排序]()⭐⭐⭐⭐ 

 4.1.7归并[排序]()⭐⭐⭐⭐ 

 4.1.8快速[排序]()⭐⭐⭐⭐⭐ 

 4.1.9快排的partition函数与归并的Merge函数⭐⭐⭐ 

##  4.2 STL库相关 

 4.2.1 vector list异同⭐⭐⭐⭐⭐ 

 4.2.2 vector内存是怎么增长的vector的底层实现⭐⭐⭐⭐ 

 4.2.3 vector和deque的比较⭐⭐⭐⭐ 

 4.2.4为什么stl里面有sort函数list里面还要再定义一个sort⭐⭐⭐ 

 4.2.5 STL底层数据结构实现⭐⭐⭐⭐ 

 4.2.6利用迭代器删除元素会发生什么？⭐⭐⭐⭐ 

 4.2.7 map是如何实现的，查找效率是多少⭐⭐⭐⭐⭐ 

 4.2.8几种模板插入的时间复杂度 ⭐⭐⭐⭐⭐ 

#  第五章Linux操作系统常见面试题 

##  5.1 Linux内核相关 

 **5.1.1 Linux内核的组成⭐⭐** 

Linux内核主要由五个子系统组成：进程调度，内存管理，虚拟文件系统，网络接口，进程间通信。

 **5.1.2用户空间与内核通信方式有哪些？⭐⭐⭐⭐⭐** 

1)系统调用。用户空间进程通过系统调用进入内核空间，访问指定的内核空间数据；

2)驱动程序。用户空间进程可以使用封装后的系统调用接口访问驱动设备节点，以和运行在内核空间的驱动程序通信；

3)共享内存mmap。在代码中调用接口，实现内核空间与用户空间的地址映射，在实时性要求很高的项目中为首选，省去拷贝数据的时间等资源，但缺点是不好控制；

4)copy_to_user()、copy_from_user()，是在驱动程序中调用接口，实现用户空间与内核空间的数据拷贝操作，应用于实时性要求不高的项目中。

 **5.1.3系统调用read()/write()，内核具体做了哪些事情⭐⭐** 

 **5.1.4系统调用的作用⭐⭐⭐⭐⭐** 

 **5.1.5内核态，用户态的区别⭐⭐⭐⭐⭐** 

 **5.1.6 bootloader内核 根文件的关系⭐⭐⭐⭐** 

 **5.1.7 Bootloader多数有两个阶段的启动过程：⭐⭐⭐** 

 **5.1.8 linux的内核是由bootloader装载到内存中的？⭐⭐⭐** 

 **5.1.9为什么需要BootLoader⭐⭐⭐⭐** 

 **5.1.10 Linux内核同步方式总结⭐⭐⭐⭐** 

 **5.1.11为什么自旋锁不能睡眠 而在拥有信号量时就可以？⭐⭐⭐⭐** 

 **5.1.12 linux下检查内存状态的命令⭐⭐⭐** 

 


##  5.2 其他操作系统常见面试题 

 **5.2.1大小端的区别以及各自的优点，哪种时候用⭐⭐⭐⭐⭐** 

 **5.2.2  一个程序从开始运行到结束的完整过程（四个过程）⭐⭐⭐⭐⭐** 

 **5.2.3什么是堆，栈，内存泄漏和内存溢出？⭐⭐⭐⭐** 

 **5.2.4堆和栈的区别⭐⭐⭐⭐⭐** 

 **5.2.5死锁的原因、条件 创建一个死锁，以及如何预防⭐⭐⭐⭐⭐** 

 **5.2.6硬链接与软链接的区别；⭐⭐⭐⭐⭐** 

 **5.2.7虚拟内存，虚拟地址与物理地址的转换⭐⭐⭐⭐** 

 **5.2.8计算机中，32bit与64bit有什么区别⭐⭐⭐** 

 **5.2.9中断和异常的区别⭐⭐⭐⭐⭐** 

 **5.2.10中断怎么发生，中断处理大概流程⭐⭐⭐⭐** 

 **5.2.11  Linux 操作系统挂起、休眠、关机相关命令⭐⭐** 

 **5.2.12数据库为什么要建立索引，以及索引的缺点⭐⭐** 

 


#  第六章 单片机常见面试题 

 **6.1 CPU  内存 虚拟内存 磁盘/硬盘 的关系⭐⭐⭐** 

 **6.2 CPU内部结构⭐⭐⭐⭐** 

 **6.3 ARM结构处理器简析  ⭐⭐** 

 **6.4波特率是什么，为什么双方波特率要相同，高低波特率有什么区别；⭐⭐⭐⭐** 

 **6.5arm和dsp有什么区别⭐⭐** 

 **6.6 ROM RAM的概念浅析⭐⭐⭐** 

 **6.7 IO口工作方式：上拉输入 下拉输入 推挽输出 开漏输出⭐⭐⭐⭐** 

 **6.8扇区 块 页 簇的概念⭐⭐⭐⭐** 

 **6.9简述处理器在读内存的过程中，CPU核、cache、MMU如何协同工作？画出CPU核、cache、MMU、内存之间的关系示意图加以说明⭐⭐** 

 **6.10请说明总线接口USRT、I2C、USB的异同点（串/并、速度、全/半双工、总线拓扑等）⭐⭐⭐⭐⭐** 

 **6.11什么是异步串口和同步串口⭐⭐⭐⭐⭐** 

 **6.12 I2C时序图⭐⭐⭐⭐⭐**

**化列表的概念，为什么用成员初始化列表会快一些（性能优势）？⭐⭐⭐⭐** 

**stm32f103性能**

**特点**

内核：ARM32位Cortex-M3 CPU，最高工作频率72MHz，1.25DMIPS/MHz。单周期乘法和硬件除法。

存储器：片上集成32-512KB的[Flash存储器](https://baike.baidu.com/item/Flash存储器/1254787)。6-64KB的[SRAM](https://baike.baidu.com/item/SRAM/7705927)存储器。

时钟、复位和[电源管理](https://baike.baidu.com/item/电源管理/1190367)：2.0-3.6V的电源供电和[I/O接口](https://baike.baidu.com/item/I%2FO接口/2682517)的驱动电压。上电复位（[POR](https://baike.baidu.com/item/POR/10912499)）、掉电复位（[PDR](https://baike.baidu.com/item/PDR/13975159)）和可编程的电压探测器（PVD）。4-16MHz的晶振。内嵌出厂前调校的8MHz [RC振荡电路](https://baike.baidu.com/item/RC振荡电路/2879502)。内部40 kHz的RC振荡电路。用于CPU时钟的[PLL](https://baike.baidu.com/item/PLL/10320802)。带校准用于[RTC](https://baike.baidu.com/item/RTC)的32kHz的晶振。

低功耗：3种低功耗模式：休眠，停止，待机模式。为RTC和备份寄存器供电的VBAT。

调试模式：串行调试（SWD）和[JTAG接口](https://baike.baidu.com/item/JTAG接口/8854374)。

DMA：12通道DMA控制器。支持的外设：定时器，ADC，DAC，SPI，IIC和UART。

3个12位的us级的[A/D转换器](https://baike.baidu.com/item/A%2FD转换器/4883848)（16通道）：A/D测量范围：0-3.6V。双采样和保持能力。片上集成一个温度传感器。

2通道12位D/A转换器：STM32F103xC,STM32F103xD,STM32F103xE独有。

最多高达112个的快速[I/O端口](https://baike.baidu.com/item/I%2FO端口/4414518)：根据型号的不同，有26，37，51，80，和112的I/O端口，所有的端口都可以映射到16个外部中断向量。除了模拟输入，所有的都可以接受5V以内的输入。

最多多达11个定时器：4个16位定时器，每个定时器有4个IC/OC/PWM或者[脉冲计数器](https://baike.baidu.com/item/脉冲计数器/10713267)。2个16位的6通道高级控制定时器：最多6个通道可用于PWM输出。2个[看门狗定时器](https://baike.baidu.com/item/看门狗定时器/9934948)（独立看门狗和窗口看门狗）。Systick定时器：24位倒计数器。2个16位基本定时器用于驱动DAC。

最多多达13个通信接口：2个IIC接口（SMBus/PMBus）。5个USART接口（ISO7816接口，LIN，IrDA兼容，调试控制）。3个SPI接口（18 Mbit/s），两个和IIS复用。CAN接口（2.0B）。USB 2.0全速接口。SDIO接口。

#                                      通信协议

## 1. iic协议

2.IIC特点
（1）简单性和有效性。
由于接口直接在组件之上，因此IIC总线占用的空间非常小，减少了电路板的空间和芯片管脚的数量，降低了互联成本。总线的长度可高达25英尺，并且能够以10Kbps的最大传输速率支持40个组件。
（2）多主控(multimastering)
其中任何能够进行发送和接收的设备都可以成为主总线。一个主控能够控制信号的传输和时钟频率。当然，在任何时间点上只能有一个主控。
3.IIC结构组成
IIC串行总线一般有两根信号线，一根是双向的数据线SDA，另一根是时钟线SCL，其时钟信号是由主控器件产生。所有接到IIC总线设备上的串行数据SDA都接到总线的SDA上，各设备的时钟线SCL接到总线的SCL上。对于并联在一条总线上的每个IC都有唯一的地址。
4.IIC协议
IIC总线在传输数据的过程中一共有三种类型信号，分别为：开始信号、结束信号和应答信号。这些信号中，起始信号是必需的，结束信号和应答信号，都可以不要。同时我们还要介绍其空闲状态、数据的有效性、数据传输。
（1）起始信号
当时钟线SCL为高期间，数据线SDA由高到低的跳变；
（2）停止信号
当时钟线SCL为高期间，数据线SDA由低到高的跳变；
（3）空闲状态
当IIC总线的数据线SDA和时钟线SCL两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。

（4）应答信号
发送器每发送一个字节（8个bit），就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。 
应答信号为低电平时，规定为有效应答位（ACK，简称应答位），表示接收器已经成功地接收了该字节；
应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。 

## 2. uart协议



## 3. spi协议

https://www.cnblogs.com/deng-tao/p/6004280.html

1、什么是SPI？

SPI是串行外设接口(Seria Peripheral Interface)的缩写。是 Motorola 公司推出的一
种同步串行接口技术，是一种高速的，全双工，同步的通信总线。

2、SPI优点
支持全双工通信
通信简单
数据传输速率块

3、缺点
没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据
可靠性上有一定的缺陷。

4、特点
1）：高速、同步、全双工、非差分、总线式
2）：主从机通信模式

5、协议通信时序详解
1）：SPI的通信原理很简单，它以主从方式工作，这种模式通常有一个主设备和一个或多
个从设备，需要至少4根线，事实上3根也可以(单向传输时)。也是所有基于SPI的设备共
有的，它们是SDI(数据输入)、SDO(数据输出)、SCLK(时钟)、CS(片选)。
(1)SDO/MOSI – 主设备数据输出，从设备数据输入;
(2)SDI/MISO – 主设备数据输入，从设备数据输出;
(3)SCLK – 时钟信号，由主设备产生;
(4)CS/SS – 从设备使能信号，由主设备控制。当有多个从设备的时候，因为每个从设
备上都有一个片选引脚接入到主设备机中，当我们的主设备和某个从设备通信时将需
要将从设备对应的片选引脚电平拉低或者是拉高。

需要说明的是，我们SPI通信有4种不同的模式，不同的从设备可能在出厂是就是配置为某种模式，这是不能改变的；但我们的通信双方必须是工作在同一模式下，所以我们可以对我们的主设备的SPI模式进行配置，通过CPOL（时钟极性）和CPHA（时钟相位）来控制我们主设备的通信模式

CPOL=0，表示当SCLK=0时处于空闲态，所以有效状态就是SCLK处于高电平时
CPOL=1，表示当SCLK=1时处于空闲态，所以有效状态就是SCLK处于低电平时
CPHA=0，表示数据采样是在第1个边沿，数据发送在第2个边沿
CPHA=1，表示数据采样是在第2个边沿，数据发送在第1个边沿

## 4. tcp/ip协议



## 5. modubus协议



## 6.面经整理

格力，云从科技，CVTE，小米，美的，华为

1 有了进程为什么还要有线程
2 死锁四个条件
3 c内存分配
4 static作用
5 嵌入式和pc端区别
6 常用的中断分类



讲一下你做的随便一个[项目]()，常用什么语言？ 
 讲一下空类自带哪些函数？ 
 拷贝构造函数 
 进程和线程中通信方法 
 有没有用过socket 
 statics 
 extern 
 extern C 
 new 和malloc的区别 
内存泄露的原因 
 宏定义do while0 
 讲一下三次握手和四次挥手？为啥？ 
 解释常用[排序]()[算法]() 
 手撕[二叉树]()BFS

